/*
Задача 8. Хеш-таблица (10 баллов)
Реализуйте структуру данных типа “множество строк” на основе динамической
хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из
строчных латинских букв.
Хеш-функция строки должна быть реализована с помощью вычисления значения
многочлена методом Горнера.
Начальный размер таблицы должен быть равным 8-ми. Перехеширование
выполняйте при добавлении элементов в случае, когда коэффициент
заполнения таблицы достигает 3/4.
Структура данных должна поддерживать операции добавления строки в
множество, удаления строки из множества и проверки принадлежности
данной строки множеству.

1_2. Для разрешения коллизий используйте двойное хеширование.
Формат входных данных
Каждая строка входных данных задает одну операцию над множеством. Запись
операции состоит из типа операции и следующей за ним через пробел строки,
над которой проводится операция.
Тип операции  – один из трех символов:
    +  означает добавление данной строки в множество;
    -  означает удаление  строки из множества;
    ?  означает проверку принадлежности данной строки множеству.
При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в
этом множестве. При удалении элемента из множества НЕ ГАРАНТИРУЕТСЯ, что он
 присутствует в этом множестве.
Формат выходных данных
Программа должна вывести для каждой операции одну из двух строк OK или FAIL.
Для операции '?': OK, если элемент присутствует в множестве. FAIL иначе.
Для операции '+': FAIL, если добавляемый элемент уже присутствует в множестве
и потому не может быть добавлен. OK иначе.
Для операции '-': OK, если элемент присутствовал в множестве и успешно удален.
FAIL иначе.

stdin
+ hello
+ bye
? bye
+ bye
- bye
? bye
? hello

stdout
OK
OK
OK
FAIL
OK
FAIL
OK

*/

#include <iostream>
#include <string>
#include <vector>
#include <cassert>

class HashTable {
public:
    explicit HashTable(const int capacity) : table(capacity, "") {};

    bool Has(const std::string &s) const;

    bool Add(const std::string &s);

    bool Remove(const std::string &s);

private:
    void RehashTable();

    unsigned int CalcHash(const std::string &s) const {
        //вычисление хэша многочленом методом Горнера
        unsigned int hash = 0;
        for (const char &ch : s) {
            hash += (hash * 37 + ch) % table.size();
        }
        return hash;
    }

    unsigned int CalcHash2(const std::string &s) const {
        //в качестве второго хэша - (сумма первого и последнего символа) * 2 + 1 -- чтобы нечётное число получилось
        return ((s[0] + s[s.length() - 1]) * 2 + 1) % table.size();
    }

    //количество занятых элементов
    size_t size = 0;
    //Хеш-таблица - вектор строк. Если строка пустая, то данный элемент пустой.
    //Значение "0" будем использовать как признак, что в этом элементе раньше было какое-то значение.
    //По условию задачи реальные строки, которые будут записываться в таблицу,
    //непустые и состоят из строчных латинских букв.
    std::vector<std::string> table;
};


bool HashTable::Has(const std::string &s) const {
    assert(!s.empty());
    unsigned int hash = CalcHash(s);
    size_t pos = hash % table.size();
    unsigned int hash2 = CalcHash2(s);
    size_t c = 0; //счётчик числа пробирований
    while (!table[pos].empty()) {
        if (c++ >= table.size()) {
            //Проверка зацикливания.
            //У нас может случиться ситуация, когда в таблице все свободные элементы ранее уже содержали какое-то
            //значение. В этом случае выходим из цикла, когда просмотрим все элементы таблицы.
            break;
        }
        if (table[pos] == s) {
            //Нашли значение
            return true;
        }
        pos = (pos + hash2) % table.size();
    }
    //Не нашли
    return false;
}

bool HashTable::Add(const std::string &s) {
    assert(!s.empty());
    if (size * 4 >= table.size() * 3) {
        //Если size >= 0.75 * capacity, увеличим таблицу в 2 раза и сделаем рехэширование
        RehashTable();
    }

    unsigned int hash = CalcHash(s);
    size_t pos = hash % table.size();
    unsigned int hash2 = CalcHash2(s);
    int firstFree = -1;
    size_t c = 0; //счётчик числа пробирований
    while (!table[pos].empty()) {
        if (c++ >= table.size()) {
            //Проверка зацикливания.
            //У нас может случиться ситуация, когда в таблице все свободные элементы ранее уже содержали какое-то
            //значение. В этом случае выходим из цикла, когда просмотрим все элементы таблицы.
            break;
        }
        if (table[pos] == "0") {
            //Нулём помечены ранее удалённые элементы
            if (firstFree == -1) {
                //Запомним первый встретившийся пустой элемент.
                //Просто записать здесь данные и выйти из цикла нельзя, так как наше значение может лежать где-нибудь
                //дальше в цепочке пробирования.
                firstFree = pos;
            }
        } else {
            if (table[pos] == s) {
                //Пришли в элемент, в котором уже лежит это значение - добавить не можем.
                return false;
            }
        }
        pos = (pos + hash2) % table.size();
    }
    if (firstFree != -1) {
        //Запишем наши данные на место первого пустого элемента
        table[firstFree] = s;
    } else {
        //Запишем новый элемент в таблицу
        table[pos] = s;
    }
    size++;
    return true;
}

void HashTable::RehashTable() {
    std::vector<std::string> oldTable = std::move(table);
    table.resize(oldTable.size() * 2, "");
    size = 0;
    for (const auto &s: oldTable) {
        if ((!s.empty()) && (s != "0")) {
            Add(s);
        }
    }
}

bool HashTable::Remove(const std::string &s) {
    assert(!s.empty());
    unsigned int hash = CalcHash(s);
    size_t pos = hash % table.size();
    unsigned int hash2 = CalcHash2(s);
    int c = 0; //счётчик числа пробирований
    while (!table[pos].empty()) {
        if (c++ >= table.size()) {
            //Проверка зацикливания.
            //У нас может случиться ситуация, когда в таблице все свободные элементы ранее уже содержали какое-то
            //значение. В этом случае выходим из цикла, когда просмотрим все элементы таблицы.
            break;
        }
        if (table[pos] == s) {
            //Нашли удаляемое значение, запишем в этот элемент "0", как признак того, что он теперь снова "пустой".
            //В реальных данных "0" не может встретиться, так как по условию у нас строки могут состоять только из
            //строчных латинских букв.
            table[pos] = "0";
            //Можно было бы не уменьшать здесь size, в этом случае у нас рехеширование делалось бы в случае,
            //когда кол-во занятых + кол-во освобождённых элементов станет >= 0.75 от размера таблицы.
            //Гарантированно были бы пустые элементы в таблице и не нужны были бы проверки зацикливания.
            size--;
            return true;
        }
        pos = (pos + hash2) % table.size();
    }
    //Не нашли
    return false;
}

int main() {
    HashTable table(8);

    char command = ' ';
    std::string value;
    while (std::cin >> command >> value) {
        switch (command) {
            case '?':
                std::cout << (table.Has(value) ? "OK" : "FAIL") << std::endl;
                break;
            case '+':
                std::cout << (table.Add(value) ? "OK" : "FAIL") << std::endl;
                break;
            case '-':
                std::cout << (table.Remove(value) ? "OK" : "FAIL") << std::endl;
                break;
            default:
                break;
        }
    }

    return 0;
}

